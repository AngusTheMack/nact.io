webpackJsonp([992631944225],{380:function(e,o){e.exports={data:{allPostTitles:{edges:[{node:{frontmatter:{title:"Decoders and Encoders",lesson:2,category:"future-reasonml",chapter:4,type:"lesson"},fields:{slug:"/decoders-and-encoders"}}}]},postBySlug:{html:'<h2 id="schema-evolution"><a href="#schema-evolution" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Schema evolution</h2>\n<p>Evolution is a natural part of a systems lifecycle; requirements change, reality sets in and bugs are fixed.\nAs a result, migrating data from one version to another is a normal part of running a system in production.</p>\n<p>One approach to schema evolution is running some kind of batch job which upgrades the old types to the new in-place.\nThis approach is not without its risks: if done without discipline, there is the chance of data loss and other unhappy happenstances. It also goes against the philosophy of data immutability. Another downside of this approach to migration is that due to  the behavior of stateful actors, an all or nothing migration would likely require downtime.  </p>\n<p>An alternative approach which fits in with the idea of event sourcing and immutable data is lazy upgrades between schema versions</p>\n<p>For example let us imagine we have versions <code>S</code><sub><code>1</code></sub>, <code>S</code><sub><code>2</code></sub> and <code>S</code><sub><code>3</code></sub> of a schema <code>S</code>. Messages <code>m</code><sub><code>1</code></sub> and <code>m</code><sub><code>2</code></sub> were persisted with <code>S</code><sub><code>1</code></sub>, while <code>m</code><sub><code>3</code></sub> was saved with <code>S</code><sub><code>2</code></sub>. We\'ve made a change and are forced to use <code>S</code><sub><code>3</code></sub> of the schema. When replaying messages, all we need to do is define two functions: <code>S</code><sub><code>1</code></sub><code>=></code> <code>S</code><sub><code>2</code></sub> and <code>S</code><sub><code>2</code></sub><code>=></code> <code>S</code><sub><code>3</code></sub>. We apply <code>S</code><sub><code>2</code></sub><code>=></code> <code>S</code><sub><code>3</code></sub> to <code>m</code><sub><code>3</code></sub> to upgrade it to latest version of the <code>S</code>. For <code>m</code><sub><code>2,3</code></sub> we map <code>S</code><sub><code>1</code></sub><code>=></code> <code>S</code><sub><code>2</code></sub> then map from <code>S</code><sub><code>2</code></sub><code>=></code> <code>S</code><sub><code>3</code></sub> to complete the upgrade. Being able to support this strategy was the primary motivation for introducing decoders and encoders.</p>\n<h2 id="persistent-actors-and-json"><a href="#persistent-actors-and-json" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Persistent Actors and JSON</h2>\n<p>Nact uses JSON for persistence and message passing. This means that in the ReasonML implementation, it uses the underlying mapping of BuckleScript types to JavaScript as a crutch so that users don\'t immediately have to worry about serialization and deserialization. However this should very much be a concern when engineering a robust production grade system. </p>\n<p>The <code>spawnPersistent</code> function includes a number of optional arguments, namely <code>~encoder</code>, <code>~stateEncoder</code>, <code>~decoder</code> and <code>~stateDecoder</code>. These functions decode <code>Js.Json.t</code> values into Reason types and encode Reason types into types of <code>Js.Json.t</code>. The decoders are well suited to performing schema evolution, while the encoders are useful for adding version information and creating a more stable persistent representation. </p>\n<h2 id="cracking-the-code"><a href="#cracking-the-code" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Cracking the Code</h2>\n<p>The <code>DaVinci_Decode</code> example below demonstrates how to <a href="https://en.wikipedia.org/wiki/ROT13">ROT<sub>13</sub></a>.</p>',timeToRead:2,excerpt:"Schema evolution Evolution is a natural part of a systems lifecycle; requirements change, reality sets in and bugs are fixed. \nAs a result...",frontmatter:{title:"Decoders and Encoders",cover:"https://unsplash.it/400/300/?random?BoldMage",date:"28/01/2018",category:"future-reasonml",tags:["getting-started","nact","reason","bucklescript"]},fields:{slug:"/decoders-and-encoders"}}},pathContext:{slug:"/decoders-and-encoders",category:"future-reasonml"}}}});
//# sourceMappingURL=path---lesson-future-reasonml-decoders-and-encoders-0288de66872ad97c993c.js.map